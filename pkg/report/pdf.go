package report

import (
	"fmt"
	"io"
	"strings"
	"time"

	"github.com/jung-kurt/gofpdf"
)

type PDFReportGenerator struct {
	pdf           *gofpdf.Fpdf
	report        *ScanReport
	pageWidth     float64
	pageHeight    float64
	leftMargin    float64
	rightMargin   float64
	contentWidth  float64
	currentY      float64
	colorPrimary  []int
	colorSecondary []int
	colorDanger   []int
	colorWarning  []int
	colorSuccess  []int
	colorInfo     []int
}

func NewPDFReportGenerator(report *ScanReport) *PDFReportGenerator {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.SetAutoPageBreak(true, 15)
	
	pageWidth, pageHeight := pdf.GetPageSize()
	leftMargin, _, rightMargin, _ := pdf.GetMargins()
	
	return &PDFReportGenerator{
		pdf:           pdf,
		report:        report,
		pageWidth:     pageWidth,
		pageHeight:    pageHeight,
		leftMargin:    leftMargin,
		rightMargin:   rightMargin,
		contentWidth:  pageWidth - leftMargin - rightMargin,
		colorPrimary:  []int{41, 65, 114},
		colorSecondary: []int{100, 100, 100},
		colorDanger:   []int{192, 57, 43},
		colorWarning:  []int{230, 126, 34},
		colorSuccess:  []int{39, 174, 96},
		colorInfo:     []int{52, 152, 219},
	}
}

func (g *PDFReportGenerator) Generate(w io.Writer) error {
	g.addCoverPage()
	g.addExecutiveSummary()
	g.addFindingsSummary()
	g.addDetailedFindings()
	g.addAppendix()
	
	return g.pdf.Output(w)
}

func (g *PDFReportGenerator) addCoverPage() {
	g.pdf.AddPage()
	
	g.pdf.SetFillColor(g.colorPrimary[0], g.colorPrimary[1], g.colorPrimary[2])
	g.pdf.Rect(0, 0, g.pageWidth, 80, "F")
	
	g.pdf.SetTextColor(255, 255, 255)
	g.pdf.SetFont("Helvetica", "B", 28)
	g.pdf.SetY(25)
	g.pdf.CellFormat(0, 12, "Database Security Assessment", "", 1, "C", false, 0, "")
	
	g.pdf.SetFont("Helvetica", "", 14)
	g.pdf.SetY(45)
	g.pdf.CellFormat(0, 8, "Exposure and Vulnerability Report", "", 1, "C", false, 0, "")
	
	g.pdf.SetY(100)
	g.pdf.SetTextColor(0, 0, 0)
	g.pdf.SetFont("Helvetica", "", 12)
	
	g.pdf.SetX(50)
	g.pdf.CellFormat(50, 8, "Report Generated:", "", 0, "L", false, 0, "")
	g.pdf.CellFormat(0, 8, g.report.GeneratedAt.Format("January 2, 2006 15:04:05"), "", 1, "L", false, 0, "")
	
	g.pdf.SetX(50)
	g.pdf.CellFormat(50, 8, "Scan Duration:", "", 0, "L", false, 0, "")
	g.pdf.CellFormat(0, 8, g.report.ScanInfo.ScanDuration.Round(time.Second).String(), "", 1, "L", false, 0, "")
	
	g.pdf.SetX(50)
	g.pdf.CellFormat(50, 8, "Targets Scanned:", "", 0, "L", false, 0, "")
	targets := strings.Join(g.report.ScanInfo.Targets, ", ")
	if len(targets) > 60 {
		targets = targets[:57] + "..."
	}
	g.pdf.CellFormat(0, 8, targets, "", 1, "L", false, 0, "")
	
	g.pdf.SetX(50)
	g.pdf.CellFormat(50, 8, "Scan Profile:", "", 0, "L", false, 0, "")
	g.pdf.CellFormat(0, 8, g.report.ScanInfo.ScanProfile, "", 1, "L", false, 0, "")
	
	if g.report.ScanInfo.NmapVersion != "" {
		g.pdf.SetX(50)
		g.pdf.CellFormat(50, 8, "Nmap Version:", "", 0, "L", false, 0, "")
		g.pdf.CellFormat(0, 8, g.report.ScanInfo.NmapVersion, "", 1, "L", false, 0, "")
	}
	
	g.addRiskIndicator(140)
	
	g.pdf.SetY(250)
	g.pdf.SetFont("Helvetica", "I", 9)
	g.pdf.SetTextColor(100, 100, 100)
	g.pdf.CellFormat(0, 6, "This report was generated by Database Exposure Scanner", "", 1, "C", false, 0, "")
	g.pdf.CellFormat(0, 6, "For authorized security assessment purposes only", "", 1, "C", false, 0, "")
}

func (g *PDFReportGenerator) addRiskIndicator(y float64) {
	g.pdf.SetY(y)
	g.pdf.SetFont("Helvetica", "B", 14)
	g.pdf.SetTextColor(0, 0, 0)
	g.pdf.CellFormat(0, 10, "Overall Risk Assessment", "", 1, "C", false, 0, "")
	
	overallRisk := RiskInfo
	if len(g.report.Services) > 0 {
		for _, svc := range g.report.Services {
			if svc.RiskAssessment.OverallRisk == RiskCritical {
				overallRisk = RiskCritical
				break
			} else if svc.RiskAssessment.OverallRisk == RiskHigh && overallRisk != RiskCritical {
				overallRisk = RiskHigh
			} else if svc.RiskAssessment.OverallRisk == RiskMedium && overallRisk != RiskCritical && overallRisk != RiskHigh {
				overallRisk = RiskMedium
			} else if svc.RiskAssessment.OverallRisk == RiskLow && overallRisk == RiskInfo {
				overallRisk = RiskLow
			}
		}
	}
	
	var riskColor []int
	var riskText string
	switch overallRisk {
	case RiskCritical:
		riskColor = []int{192, 57, 43}
		riskText = "CRITICAL"
	case RiskHigh:
		riskColor = []int{231, 76, 60}
		riskText = "HIGH"
	case RiskMedium:
		riskColor = []int{230, 126, 34}
		riskText = "MEDIUM"
	case RiskLow:
		riskColor = []int{241, 196, 15}
		riskText = "LOW"
	default:
		riskColor = []int{39, 174, 96}
		riskText = "INFORMATIONAL"
	}
	
	g.pdf.SetY(y + 15)
	boxWidth := 80.0
	boxX := (g.pageWidth - boxWidth) / 2
	g.pdf.SetFillColor(riskColor[0], riskColor[1], riskColor[2])
	g.pdf.RoundedRect(boxX, g.pdf.GetY(), boxWidth, 25, 3, "1234", "F")
	
	g.pdf.SetTextColor(255, 255, 255)
	g.pdf.SetFont("Helvetica", "B", 18)
	g.pdf.SetY(y + 20)
	g.pdf.CellFormat(0, 10, riskText, "", 1, "C", false, 0, "")
}

func (g *PDFReportGenerator) addExecutiveSummary() {
	g.pdf.AddPage()
	g.addSectionHeader("Executive Summary")
	
	g.pdf.SetFont("Helvetica", "", 11)
	g.pdf.SetTextColor(60, 60, 60)
	
	summary := fmt.Sprintf(
		"This security assessment scanned %d target(s) across %d port(s), identifying %d database service(s). "+
			"The scan was conducted using a %s profile over a duration of %s.",
		g.report.Summary.TotalHosts,
		len(g.report.ScanInfo.PortsScanned),
		g.report.Summary.ServicesFound,
		g.report.ScanInfo.ScanProfile,
		g.report.ScanInfo.ScanDuration.Round(time.Second),
	)
	
	g.pdf.MultiCell(0, 6, summary, "", "L", false)
	g.pdf.Ln(5)
	
	g.addSubSectionHeader("Key Findings")
	
	totalFindings := g.report.Summary.CriticalFindings + g.report.Summary.HighFindings +
		g.report.Summary.MediumFindings + g.report.Summary.LowFindings
	
	keyFindings := fmt.Sprintf(
		"A total of %d finding(s) were identified during this assessment:\n"+
			"- Critical severity: %d\n"+
			"- High severity: %d\n"+
			"- Medium severity: %d\n"+
			"- Low severity: %d",
		totalFindings,
		g.report.Summary.CriticalFindings,
		g.report.Summary.HighFindings,
		g.report.Summary.MediumFindings,
		g.report.Summary.LowFindings,
	)
	
	g.pdf.SetFont("Helvetica", "", 11)
	g.pdf.MultiCell(0, 6, keyFindings, "", "L", false)
	g.pdf.Ln(5)
	
	if g.report.Summary.CriticalFindings > 0 || g.report.Summary.HighFindings > 0 {
		g.addSubSectionHeader("Immediate Action Required")
		g.pdf.SetFont("Helvetica", "", 11)
		g.pdf.SetTextColor(192, 57, 43)
		
		actions := []string{}
		
		for _, svc := range g.report.Services {
			if svc.Authentication.AnonymousAccess {
				actions = append(actions, fmt.Sprintf("Enable authentication on %s:%d (%s)",
					svc.Identification.Host, svc.Identification.Port, svc.Identification.ServiceType))
			}
			if svc.Authentication.DefaultCredentials {
				actions = append(actions, fmt.Sprintf("Change default credentials on %s:%d (%s)",
					svc.Identification.Host, svc.Identification.Port, svc.Identification.ServiceType))
			}
			if !svc.VersionTransport.TLSEnabled {
				actions = append(actions, fmt.Sprintf("Enable TLS encryption on %s:%d (%s)",
					svc.Identification.Host, svc.Identification.Port, svc.Identification.ServiceType))
			}
		}
		
		for i, action := range actions {
			if i >= 5 {
				g.pdf.MultiCell(0, 6, fmt.Sprintf("... and %d more critical actions", len(actions)-5), "", "L", false)
				break
			}
			g.pdf.MultiCell(0, 6, fmt.Sprintf("%d. %s", i+1, action), "", "L", false)
		}
		g.pdf.SetTextColor(60, 60, 60)
	}
}

func (g *PDFReportGenerator) addFindingsSummary() {
	g.pdf.AddPage()
	g.addSectionHeader("Findings Summary")
	
	g.addFindingsTable()
	g.pdf.Ln(10)
	
	g.addServiceTypeBreakdown()
}

func (g *PDFReportGenerator) addFindingsTable() {
	g.pdf.SetFont("Helvetica", "B", 10)
	
	headers := []string{"Host", "Port", "Service", "Risk", "Key Issues"}
	widths := []float64{35, 15, 30, 20, g.contentWidth - 100}
	
	g.pdf.SetFillColor(g.colorPrimary[0], g.colorPrimary[1], g.colorPrimary[2])
	g.pdf.SetTextColor(255, 255, 255)
	
	for i, header := range headers {
		g.pdf.CellFormat(widths[i], 8, header, "1", 0, "C", true, 0, "")
	}
	g.pdf.Ln(-1)
	
	g.pdf.SetFont("Helvetica", "", 9)
	g.pdf.SetTextColor(0, 0, 0)
	
	for i, svc := range g.report.Services {
		if i%2 == 0 {
			g.pdf.SetFillColor(245, 245, 245)
		} else {
			g.pdf.SetFillColor(255, 255, 255)
		}
		
		g.pdf.CellFormat(widths[0], 7, truncateString(svc.Identification.Host, 18), "1", 0, "L", true, 0, "")
		g.pdf.CellFormat(widths[1], 7, fmt.Sprintf("%d", svc.Identification.Port), "1", 0, "C", true, 0, "")
		g.pdf.CellFormat(widths[2], 7, truncateString(svc.Identification.ServiceType, 15), "1", 0, "L", true, 0, "")
		
		riskColor := g.getRiskColor(svc.RiskAssessment.OverallRisk)
		g.pdf.SetTextColor(riskColor[0], riskColor[1], riskColor[2])
		g.pdf.CellFormat(widths[3], 7, string(svc.RiskAssessment.OverallRisk), "1", 0, "C", true, 0, "")
		g.pdf.SetTextColor(0, 0, 0)
		
		issues := g.getKeyIssues(svc)
		g.pdf.CellFormat(widths[4], 7, truncateString(issues, 45), "1", 0, "L", true, 0, "")
		g.pdf.Ln(-1)
	}
}

func (g *PDFReportGenerator) addServiceTypeBreakdown() {
	if len(g.report.Summary.ServiceTypes) == 0 {
		return
	}
	
	g.addSubSectionHeader("Service Type Distribution")
	
	g.pdf.SetFont("Helvetica", "B", 10)
	g.pdf.SetFillColor(g.colorPrimary[0], g.colorPrimary[1], g.colorPrimary[2])
	g.pdf.SetTextColor(255, 255, 255)
	g.pdf.CellFormat(80, 8, "Service Type", "1", 0, "C", true, 0, "")
	g.pdf.CellFormat(40, 8, "Count", "1", 0, "C", true, 0, "")
	g.pdf.CellFormat(50, 8, "Percentage", "1", 1, "C", true, 0, "")
	
	g.pdf.SetFont("Helvetica", "", 10)
	g.pdf.SetTextColor(0, 0, 0)
	
	total := float64(g.report.Summary.ServicesFound)
	i := 0
	for serviceType, count := range g.report.Summary.ServiceTypes {
		if i%2 == 0 {
			g.pdf.SetFillColor(245, 245, 245)
		} else {
			g.pdf.SetFillColor(255, 255, 255)
		}
		
		percentage := (float64(count) / total) * 100
		g.pdf.CellFormat(80, 7, serviceType, "1", 0, "L", true, 0, "")
		g.pdf.CellFormat(40, 7, fmt.Sprintf("%d", count), "1", 0, "C", true, 0, "")
		g.pdf.CellFormat(50, 7, fmt.Sprintf("%.1f%%", percentage), "1", 1, "C", true, 0, "")
		i++
	}
}

func (g *PDFReportGenerator) addDetailedFindings() {
	for i, svc := range g.report.Services {
		g.pdf.AddPage()
		g.addSectionHeader(fmt.Sprintf("Finding %d: %s:%d", i+1, svc.Identification.Host, svc.Identification.Port))
		
		g.addServiceOverview(svc)
		g.addAuthenticationDetails(svc)
		g.addTLSDetails(svc)
		g.addConfigurationDetails(svc)
		g.addVulnerabilityDetails(svc)
		g.addRecommendations(svc)
	}
}

func (g *PDFReportGenerator) addServiceOverview(svc ServiceReport) {
	g.addSubSectionHeader("Service Overview")
	
	riskColor := g.getRiskColor(svc.RiskAssessment.OverallRisk)
	
	g.pdf.SetFont("Helvetica", "", 10)
	g.pdf.SetTextColor(0, 0, 0)
	
	data := [][]string{
		{"Host", svc.Identification.Host},
		{"Port", fmt.Sprintf("%d/%s", svc.Identification.Port, svc.Identification.Protocol)},
		{"Service Type", svc.Identification.ServiceType},
		{"Version", svc.VersionTransport.Version},
	}
	
	if svc.VersionTransport.Edition != "" {
		data = append(data, []string{"Edition", svc.VersionTransport.Edition})
	}
	
	for _, row := range data {
		g.pdf.SetFont("Helvetica", "B", 10)
		g.pdf.CellFormat(40, 6, row[0]+":", "", 0, "L", false, 0, "")
		g.pdf.SetFont("Helvetica", "", 10)
		g.pdf.CellFormat(0, 6, row[1], "", 1, "L", false, 0, "")
	}
	
	g.pdf.SetFont("Helvetica", "B", 10)
	g.pdf.CellFormat(40, 6, "Risk Level:", "", 0, "L", false, 0, "")
	g.pdf.SetTextColor(riskColor[0], riskColor[1], riskColor[2])
	g.pdf.SetFont("Helvetica", "B", 10)
	g.pdf.CellFormat(0, 6, string(svc.RiskAssessment.OverallRisk), "", 1, "L", false, 0, "")
	g.pdf.SetTextColor(0, 0, 0)
	
	g.pdf.Ln(3)
}

func (g *PDFReportGenerator) addAuthenticationDetails(svc ServiceReport) {
	g.addSubSectionHeader("Authentication Assessment")
	
	g.pdf.SetFont("Helvetica", "", 10)
	
	if svc.Authentication.AnonymousAccess {
		g.pdf.SetTextColor(g.colorDanger[0], g.colorDanger[1], g.colorDanger[2])
		g.pdf.MultiCell(0, 6, "[CRITICAL] Anonymous access is enabled - no authentication required", "", "L", false)
	} else if svc.Authentication.AuthRequired {
		g.pdf.SetTextColor(g.colorSuccess[0], g.colorSuccess[1], g.colorSuccess[2])
		g.pdf.MultiCell(0, 6, "[OK] Authentication is required", "", "L", false)
	}
	g.pdf.SetTextColor(0, 0, 0)
	
	if svc.Authentication.DefaultCredentials {
		g.pdf.SetTextColor(g.colorDanger[0], g.colorDanger[1], g.colorDanger[2])
		g.pdf.MultiCell(0, 6, fmt.Sprintf("[CRITICAL] Default credentials accepted: %s (Privilege: %s)",
			svc.Authentication.CredentialPattern, svc.Authentication.PrivilegeLevel), "", "L", false)
		g.pdf.SetTextColor(0, 0, 0)
	}
	
	g.pdf.SetFont("Helvetica", "", 10)
	g.pdf.CellFormat(0, 6, fmt.Sprintf("Authentication attempts: %d/%d", svc.Authentication.AttemptsMade, svc.Authentication.MaxAttempts), "", 1, "L", false, 0, "")
	
	if svc.Authentication.ErrorAnalysis != nil {
		ea := svc.Authentication.ErrorAnalysis
		if ea.LeaksUserExists || ea.LeaksPasswordWrong || ea.CleartextEnabled {
			g.pdf.Ln(2)
			g.pdf.SetFont("Helvetica", "B", 10)
			g.pdf.CellFormat(0, 6, "Error Analysis:", "", 1, "L", false, 0, "")
			g.pdf.SetFont("Helvetica", "", 10)
			
			if ea.LeaksUserExists {
				g.pdf.SetTextColor(g.colorWarning[0], g.colorWarning[1], g.colorWarning[2])
				g.pdf.CellFormat(0, 6, "  - Username enumeration possible via error messages", "", 1, "L", false, 0, "")
			}
			if ea.LeaksPasswordWrong {
				g.pdf.SetTextColor(g.colorWarning[0], g.colorWarning[1], g.colorWarning[2])
				g.pdf.CellFormat(0, 6, "  - Password validation leakage detected", "", 1, "L", false, 0, "")
			}
			if ea.CleartextEnabled {
				g.pdf.SetTextColor(g.colorDanger[0], g.colorDanger[1], g.colorDanger[2])
				g.pdf.CellFormat(0, 6, "  - Cleartext authentication enabled", "", 1, "L", false, 0, "")
			}
			g.pdf.SetTextColor(0, 0, 0)
		}
	}
	
	if len(svc.Authentication.ProtocolIssues) > 0 {
		g.pdf.Ln(2)
		g.pdf.SetFont("Helvetica", "B", 10)
		g.pdf.CellFormat(0, 6, "Protocol Issues:", "", 1, "L", false, 0, "")
		g.pdf.SetFont("Helvetica", "", 10)
		
		for _, pi := range svc.Authentication.ProtocolIssues {
			color := g.getRiskColorByString(pi.Risk)
			g.pdf.SetTextColor(color[0], color[1], color[2])
			g.pdf.CellFormat(0, 6, fmt.Sprintf("  [%s] %s", pi.Risk, pi.Issue), "", 1, "L", false, 0, "")
			g.pdf.SetTextColor(80, 80, 80)
			g.pdf.CellFormat(0, 5, fmt.Sprintf("       %s", pi.Description), "", 1, "L", false, 0, "")
		}
		g.pdf.SetTextColor(0, 0, 0)
	}
	
	if len(svc.Authentication.SecondaryServices) > 0 {
		g.pdf.Ln(2)
		g.pdf.SetFont("Helvetica", "B", 10)
		g.pdf.CellFormat(0, 6, "Secondary Services:", "", 1, "L", false, 0, "")
		g.pdf.SetFont("Helvetica", "", 10)
		
		for _, ss := range svc.Authentication.SecondaryServices {
			status := "Closed"
			if ss.Accessible {
				status = "OPEN"
			}
			color := g.getRiskColorByString(ss.Risk)
			g.pdf.SetTextColor(color[0], color[1], color[2])
			g.pdf.CellFormat(0, 6, fmt.Sprintf("  [%s] %s (port %d) - %s", ss.Risk, ss.Name, ss.Port, status), "", 1, "L", false, 0, "")
			g.pdf.SetTextColor(80, 80, 80)
			g.pdf.CellFormat(0, 5, fmt.Sprintf("       %s", ss.Description), "", 1, "L", false, 0, "")
		}
		g.pdf.SetTextColor(0, 0, 0)
	}
	
	g.pdf.Ln(3)
}

func (g *PDFReportGenerator) addTLSDetails(svc ServiceReport) {
	g.addSubSectionHeader("Transport Security (TLS)")
	
	g.pdf.SetFont("Helvetica", "", 10)
	
	if !svc.VersionTransport.TLSEnabled {
		g.pdf.SetTextColor(g.colorDanger[0], g.colorDanger[1], g.colorDanger[2])
		g.pdf.MultiCell(0, 6, "[CRITICAL] TLS/SSL is not enabled - traffic is unencrypted", "", "L", false)
		g.pdf.SetTextColor(0, 0, 0)
		g.pdf.Ln(3)
		return
	}
	
	g.pdf.SetTextColor(g.colorSuccess[0], g.colorSuccess[1], g.colorSuccess[2])
	g.pdf.CellFormat(0, 6, "[OK] TLS/SSL is enabled", "", 1, "L", false, 0, "")
	g.pdf.SetTextColor(0, 0, 0)
	
	if svc.VersionTransport.TLSDetails != nil {
		td := svc.VersionTransport.TLSDetails
		
		g.pdf.SetFont("Helvetica", "", 10)
		g.pdf.CellFormat(40, 6, "TLS Version:", "", 0, "L", false, 0, "")
		if td.WeakProtocol {
			g.pdf.SetTextColor(g.colorWarning[0], g.colorWarning[1], g.colorWarning[2])
		}
		g.pdf.CellFormat(0, 6, svc.VersionTransport.TLSVersion, "", 1, "L", false, 0, "")
		g.pdf.SetTextColor(0, 0, 0)
		
		if td.CipherSuite != "" {
			g.pdf.CellFormat(40, 6, "Cipher Suite:", "", 0, "L", false, 0, "")
			g.pdf.CellFormat(0, 6, truncateString(td.CipherSuite, 50), "", 1, "L", false, 0, "")
		}
		
		if len(td.SupportedVersions) > 0 {
			g.pdf.CellFormat(40, 6, "Supported TLS:", "", 0, "L", false, 0, "")
			g.pdf.CellFormat(0, 6, strings.Join(td.SupportedVersions, ", "), "", 1, "L", false, 0, "")
		}
		
		if td.CertSubject != "" {
			g.pdf.CellFormat(40, 6, "Cert Subject:", "", 0, "L", false, 0, "")
			g.pdf.CellFormat(0, 6, truncateString(td.CertSubject, 50), "", 1, "L", false, 0, "")
		}
		
		if td.CertIssuer != "" {
			g.pdf.CellFormat(40, 6, "Cert Issuer:", "", 0, "L", false, 0, "")
			g.pdf.CellFormat(0, 6, truncateString(td.CertIssuer, 50), "", 1, "L", false, 0, "")
		}
		
		if !td.CertExpiry.IsZero() {
			g.pdf.CellFormat(40, 6, "Cert Expiry:", "", 0, "L", false, 0, "")
			expiryText := td.CertExpiry.Format("2006-01-02")
			if td.Expired {
				g.pdf.SetTextColor(g.colorDanger[0], g.colorDanger[1], g.colorDanger[2])
				expiryText += " (EXPIRED)"
			} else if td.CertExpiry.Before(time.Now().AddDate(0, 1, 0)) {
				g.pdf.SetTextColor(g.colorWarning[0], g.colorWarning[1], g.colorWarning[2])
				expiryText += " (expires soon)"
			}
			g.pdf.CellFormat(0, 6, expiryText, "", 1, "L", false, 0, "")
			g.pdf.SetTextColor(0, 0, 0)
		}
		
		if td.SelfSigned {
			g.pdf.SetTextColor(g.colorWarning[0], g.colorWarning[1], g.colorWarning[2])
			g.pdf.CellFormat(0, 6, "[WARN] Certificate is self-signed", "", 1, "L", false, 0, "")
			g.pdf.SetTextColor(0, 0, 0)
		}
		
		if td.OCSPStatus != "" {
			g.pdf.CellFormat(40, 6, "OCSP Status:", "", 0, "L", false, 0, "")
			g.pdf.CellFormat(0, 6, td.OCSPStatus, "", 1, "L", false, 0, "")
		}
		
		weakCipherCount := 0
		for _, cs := range td.CipherSuites {
			if !cs.Secure || cs.Strength == "Weak" {
				weakCipherCount++
			}
		}
		if weakCipherCount > 0 {
			g.pdf.SetTextColor(g.colorWarning[0], g.colorWarning[1], g.colorWarning[2])
			g.pdf.CellFormat(0, 6, fmt.Sprintf("[WARN] %d weak cipher suite(s) supported", weakCipherCount), "", 1, "L", false, 0, "")
			g.pdf.SetTextColor(0, 0, 0)
		}
	}
	
	g.pdf.Ln(3)
}

func (g *PDFReportGenerator) addConfigurationDetails(svc ServiceReport) {
	if len(svc.Configuration.DangerousSettings) == 0 && svc.Configuration.ExposureInfo == nil {
		return
	}
	
	g.addSubSectionHeader("Configuration Issues")
	
	g.pdf.SetFont("Helvetica", "", 10)
	
	if svc.Configuration.ExposureInfo != nil {
		ei := svc.Configuration.ExposureInfo
		if ei.PubliclyAccessible {
			g.pdf.SetTextColor(g.colorDanger[0], g.colorDanger[1], g.colorDanger[2])
			g.pdf.CellFormat(0, 6, "[HIGH] Database is publicly accessible", "", 1, "L", false, 0, "")
			g.pdf.SetTextColor(0, 0, 0)
		}
		if ei.RemoteAccessEnabled {
			g.pdf.SetTextColor(g.colorWarning[0], g.colorWarning[1], g.colorWarning[2])
			g.pdf.CellFormat(0, 6, "[WARN] Remote access is enabled", "", 1, "L", false, 0, "")
			g.pdf.SetTextColor(0, 0, 0)
		}
	}
	
	for _, ds := range svc.Configuration.DangerousSettings {
		color := g.getRiskColorByString(ds.Risk)
		g.pdf.SetTextColor(color[0], color[1], color[2])
		g.pdf.CellFormat(0, 6, fmt.Sprintf("[%s] %s = %s", ds.Risk, ds.Name, ds.Value), "", 1, "L", false, 0, "")
		g.pdf.SetTextColor(80, 80, 80)
		g.pdf.SetFont("Helvetica", "", 9)
		g.pdf.CellFormat(0, 5, fmt.Sprintf("       %s", ds.Description), "", 1, "L", false, 0, "")
		g.pdf.SetFont("Helvetica", "", 10)
	}
	g.pdf.SetTextColor(0, 0, 0)
	
	g.pdf.Ln(3)
}

func (g *PDFReportGenerator) addVulnerabilityDetails(svc ServiceReport) {
	hasVulns := len(svc.Vulnerabilities.CVEs) > 0 ||
		svc.Vulnerabilities.EOLVersion != nil ||
		len(svc.Vulnerabilities.KnownVulnerable) > 0 ||
		len(svc.Vulnerabilities.NmapScriptOutput) > 0
	
	if !hasVulns {
		return
	}
	
	g.addSubSectionHeader("Vulnerabilities")
	
	g.pdf.SetFont("Helvetica", "", 10)
	
	if svc.Vulnerabilities.EOLVersion != nil {
		eol := svc.Vulnerabilities.EOLVersion
		g.pdf.SetTextColor(g.colorDanger[0], g.colorDanger[1], g.colorDanger[2])
		g.pdf.CellFormat(0, 6, fmt.Sprintf("[%s] End-of-Life Version: %s", eol.RiskLevel, eol.Version), "", 1, "L", false, 0, "")
		g.pdf.SetTextColor(80, 80, 80)
		g.pdf.CellFormat(0, 5, fmt.Sprintf("       EOL Date: %s - %s", eol.EOLDate, eol.Description), "", 1, "L", false, 0, "")
		g.pdf.SetTextColor(0, 0, 0)
	}
	
	for _, v := range svc.Vulnerabilities.KnownVulnerable {
		color := g.getRiskColorByString(v.RiskLevel)
		g.pdf.SetTextColor(color[0], color[1], color[2])
		g.pdf.CellFormat(0, 6, fmt.Sprintf("[%s] %s", v.RiskLevel, v.Description), "", 1, "L", false, 0, "")
		g.pdf.SetTextColor(80, 80, 80)
		g.pdf.CellFormat(0, 5, fmt.Sprintf("       CVEs: %s", strings.Join(v.CVEs, ", ")), "", 1, "L", false, 0, "")
	}
	
	for _, cve := range svc.Vulnerabilities.CVEs {
		color := g.getRiskColorByString(cve.Severity)
		g.pdf.SetTextColor(color[0], color[1], color[2])
		g.pdf.CellFormat(0, 6, fmt.Sprintf("[%s] %s", cve.Severity, cve.ID), "", 1, "L", false, 0, "")
		if cve.Description != "" {
			g.pdf.SetTextColor(80, 80, 80)
			g.pdf.CellFormat(0, 5, fmt.Sprintf("       %s", truncateString(cve.Description, 80)), "", 1, "L", false, 0, "")
		}
	}
	g.pdf.SetTextColor(0, 0, 0)
	
	g.pdf.Ln(3)
}

func (g *PDFReportGenerator) addRecommendations(svc ServiceReport) {
	if len(svc.RiskAssessment.Recommendations) == 0 {
		return
	}
	
	g.addSubSectionHeader("Recommendations")
	
	g.pdf.SetFont("Helvetica", "", 10)
	
	seen := make(map[string]bool)
	for i, rec := range svc.RiskAssessment.Recommendations {
		if seen[rec] {
			continue
		}
		seen[rec] = true
		
		g.pdf.CellFormat(0, 6, fmt.Sprintf("%d. %s", i+1, rec), "", 1, "L", false, 0, "")
	}
	
	g.pdf.Ln(3)
}

func (g *PDFReportGenerator) addAppendix() {
	g.pdf.AddPage()
	g.addSectionHeader("Appendix: Scan Methodology")
	
	g.pdf.SetFont("Helvetica", "", 10)
	g.pdf.SetTextColor(60, 60, 60)
	
	methodology := `This security assessment was conducted using the Database Exposure Scanner, a non-destructive security assessment tool designed for authorized testing purposes.

Scanning Methodology:
1. Port Discovery: TCP connection scanning to identify open database ports
2. Service Fingerprinting: Protocol-specific handshakes to identify database types and versions
3. Authentication Testing: Testing for anonymous access and common default credentials (limited attempts)
4. TLS Assessment: Evaluation of transport layer security configuration
5. Configuration Auditing: Detection of dangerous configuration settings
6. Vulnerability Mapping: Correlation with known CVEs and EOL version databases

Safety Measures:
- Maximum of 10 credential attempts per service to avoid account lockouts
- Read-only queries for configuration checks
- No brute force attacks or DoS testing
- Non-destructive assessment only

Limitations:
- This assessment does not include application-layer vulnerability testing
- Only publicly accessible services are tested
- Some vulnerabilities may require authenticated access to detect`
	
	g.pdf.MultiCell(0, 5, methodology, "", "L", false)
	g.pdf.Ln(10)
	
	g.addSubSectionHeader("Risk Severity Definitions")
	
	definitions := []struct {
		level string
		color []int
		desc  string
	}{
		{"Critical", g.colorDanger, "Immediate exploitation possible with severe impact. Requires immediate remediation."},
		{"High", []int{231, 76, 60}, "Significant security risk that could lead to data breach. Should be addressed urgently."},
		{"Medium", g.colorWarning, "Notable security weakness that increases attack surface. Plan remediation soon."},
		{"Low", []int{241, 196, 15}, "Minor security concern with limited impact. Address as part of regular maintenance."},
		{"Informational", g.colorInfo, "Security-relevant information that may be useful for hardening."},
	}
	
	for _, def := range definitions {
		g.pdf.SetTextColor(def.color[0], def.color[1], def.color[2])
		g.pdf.SetFont("Helvetica", "B", 10)
		g.pdf.CellFormat(25, 6, def.level+":", "", 0, "L", false, 0, "")
		g.pdf.SetTextColor(60, 60, 60)
		g.pdf.SetFont("Helvetica", "", 10)
		g.pdf.MultiCell(0, 6, def.desc, "", "L", false)
	}
	
	g.pdf.SetTextColor(0, 0, 0)
}

func (g *PDFReportGenerator) addSectionHeader(title string) {
	g.pdf.SetFillColor(g.colorPrimary[0], g.colorPrimary[1], g.colorPrimary[2])
	g.pdf.SetTextColor(255, 255, 255)
	g.pdf.SetFont("Helvetica", "B", 14)
	g.pdf.CellFormat(0, 10, "  "+title, "", 1, "L", true, 0, "")
	g.pdf.SetTextColor(0, 0, 0)
	g.pdf.Ln(3)
}

func (g *PDFReportGenerator) addSubSectionHeader(title string) {
	g.pdf.SetFont("Helvetica", "B", 11)
	g.pdf.SetTextColor(g.colorPrimary[0], g.colorPrimary[1], g.colorPrimary[2])
	g.pdf.CellFormat(0, 8, title, "", 1, "L", false, 0, "")
	g.pdf.SetDrawColor(g.colorPrimary[0], g.colorPrimary[1], g.colorPrimary[2])
	g.pdf.Line(g.leftMargin, g.pdf.GetY(), g.pageWidth-g.rightMargin, g.pdf.GetY())
	g.pdf.SetTextColor(0, 0, 0)
	g.pdf.Ln(2)
}

func (g *PDFReportGenerator) getRiskColor(risk RiskLevel) []int {
	switch risk {
	case RiskCritical:
		return []int{192, 57, 43}
	case RiskHigh:
		return []int{231, 76, 60}
	case RiskMedium:
		return []int{230, 126, 34}
	case RiskLow:
		return []int{241, 196, 15}
	default:
		return []int{52, 152, 219}
	}
}

func (g *PDFReportGenerator) getRiskColorByString(risk string) []int {
	switch strings.ToLower(risk) {
	case "critical":
		return []int{192, 57, 43}
	case "high":
		return []int{231, 76, 60}
	case "medium":
		return []int{230, 126, 34}
	case "low":
		return []int{241, 196, 15}
	default:
		return []int{52, 152, 219}
	}
}

func (g *PDFReportGenerator) getKeyIssues(svc ServiceReport) string {
	issues := []string{}
	
	if svc.Authentication.AnonymousAccess {
		issues = append(issues, "Anonymous access")
	}
	if svc.Authentication.DefaultCredentials {
		issues = append(issues, "Default creds")
	}
	if !svc.VersionTransport.TLSEnabled {
		issues = append(issues, "No TLS")
	}
	if svc.Vulnerabilities.EOLVersion != nil {
		issues = append(issues, "EOL version")
	}
	if len(svc.Vulnerabilities.CVEs) > 0 {
		issues = append(issues, fmt.Sprintf("%d CVEs", len(svc.Vulnerabilities.CVEs)))
	}
	
	if len(issues) == 0 {
		return "No critical issues"
	}
	
	return strings.Join(issues, ", ")
}

func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

func (r *ScanReport) WritePDF(w io.Writer) error {
	generator := NewPDFReportGenerator(r)
	return generator.Generate(w)
}
